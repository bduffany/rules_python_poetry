package gazelle

import (
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (pythonLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	srcs := r.AttrStrings("srcs")
	specs := make([]resolve.ImportSpec, len(srcs))
	for i, src := range srcs {
		specs[i] = resolve.ImportSpec{Lang: pythonLangName, Imp: filepath.Join(f.Pkg, src)}
	}
	return specs
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (pythonLang) Embeds(r *rule.Rule, from label.Label) []label.Label { return nil }

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (pythonLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	rsv := &resolver{
		config:      c,
		index:       ix,
		remoteCache: rc,
		rule:        r,
		imports:     importsRaw.([]importInfo),
		from:        from,
	}
	rsv.resolve()
}

type resolver struct {
	config      *config.Config
	index       *resolve.RuleIndex
	remoteCache *repo.RemoteCache
	rule        *rule.Rule
	imports     []importInfo
	from        label.Label
}

func (r *resolver) resolve() {
	var labels []label.Label
	for _, imp := range r.imports {
		labels = append(labels, r.resolveImport(imp)...)
	}

	switch r.rule.Kind() {
	case pythonBinRule:
		labels = append(labels, r.resolveInits(r.from.Pkg, true)...)
	case pythonPytestRule:
		labels = append(labels, r.resolveConftest()...)
	}

	depSet := make(map[string]bool)
	for _, l := range labels {
		l = l.Rel(r.from.Repo, r.from.Pkg)
		depSet[l.String()] = true
	}

	r.rule.DelAttr("deps")
	if len(depSet) > 0 {
		deps := make([]string, 0, len(depSet))
		for dep := range depSet {
			deps = append(deps, dep)
		}
		sort.Strings(deps)
		r.rule.SetAttr("deps", deps)
	}
}

func (r *resolver) resolveImport(imp importInfo) []label.Label {
	pc := getConfig(r.config)

	// For an import like `import X` or `from X import Y`, there are 4 possibilities
	// for what `X` could refer to:
	// 1. A module, i.e. `foo.py`.
	// 2. A non-namespace package's init module, i.e. `foo/__init__.py`.
	// 3. A namespace package, i.e. the `foo/` directory.
	// 4. A third party package, i.e. the `foo` package.
	// For cases 2-4,

	var labels []label.Label
	if imp.IsFromImport() {
		if labels := r.resolveModule(imp.filePath); len(labels) > 0 {
			return labels
		}
		for _, fromImport := range imp.fromImports {
			fromImportPath := filepath.Join(imp.filePath, fromImport)
			labels = append(labels, r.resolvePath(imp, fromImportPath, pc)...)
		}
	} else {
		labels = r.resolvePath(imp, imp.filePath, pc)
	}
	return labels
}

func (r *resolver) resolveModule(path string) []label.Label {
	modulePath := path + ".py"
	l := r.resolveWithIndex(modulePath)
	if l == label.NoLabel {
		return nil
	}
	labels := []label.Label{l}
	labels = append(labels, r.resolveInits(path, false)...)
	return labels
}

func (r *resolver) resolvePath(imp importInfo, path string, pc *pyConfig) []label.Label {
	// Case 1: A module.
	if labels := r.resolveModule(path); len(labels) > 0 {
		return labels
	}

	// Case 2: A non-namespace package's init module.
	initPath := filepath.Join(path, "__init__.py")
	l := r.resolveWithIndex(initPath)

	var isNamespace bool
	if l == label.NoLabel {
		// Case 3: A namespace package.
		info, err := os.Stat(filepath.Join(r.config.RepoRoot, path))
		isNamespace = err == nil && info.IsDir()
	}

	if l == label.NoLabel && imp.IsFromImport() {
		initPath := filepath.Join(filepath.Dir(path), "__init__.py")
		l = r.resolveWithIndex(initPath)
	}

	if l == label.NoLabel && !isNamespace {
		// Case 4: A third party package.
		thirdPartyPkgName := strings.Split(imp.importPath, ".")[0]
		for importPrefix, pkgName := range pc.thirdPartyImportPrefixes {
			if strings.HasPrefix(imp.importPath, importPrefix) {
				thirdPartyPkgName = pkgName
			}
		}
		return []label.Label{label.New(repoName(thirdPartyPkgName), "", "lib")}
	}

	var labels []label.Label
	if l != label.NoLabel {
		// l will be NoLabel iff importPath refers to a namespace package.
		labels = append(labels, l)
	}
	labels = append(labels, r.resolveInits(path, false)...)

	return labels
}

func (r *resolver) resolveConftest() []label.Label {
	var labels []label.Label
	for dir := r.from.Pkg; dir != "."; dir = filepath.Dir(dir) {
		conftestPath := filepath.Join(dir, "conftest.py")
		if l := r.resolveWithIndex(conftestPath); l != label.NoLabel {
			labels = append(labels, l)
		}
	}
	return labels
}

func (r *resolver) resolveInits(importPath string, includeCommon bool) []label.Label {
	var labels []label.Label
	for dir := importPath; dir != "."; dir = filepath.Dir(dir) {
		if !includeCommon {
			if rel, err := filepath.Rel(dir, r.from.Pkg); err == nil && !strings.HasPrefix(rel, "..") {
				break
			}
		}

		initPath := filepath.Join(dir, "__init__.py")
		if l := r.resolveWithIndex(initPath); l != label.NoLabel {
			labels = append(labels, l)
		}
	}
	return labels
}

func (r *resolver) resolveWithIndex(path string) label.Label {
	matches := r.index.FindRulesByImportWithConfig(r.config, resolve.ImportSpec{Lang: pythonLangName, Imp: path}, pythonLangName)
	if len(matches) != 1 {
		return label.NoLabel
	}
	if matches[0].IsSelfImport(r.from) {
		return label.NoLabel
	}
	return matches[0].Label
}
